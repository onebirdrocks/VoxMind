import Foundation
import Speech
import SwiftUI
import Translation // *** Ensure correct import for Translation Framework ***
import Combine // For NotificationCenter observers
import AVFoundation
import CoreMedia

// Import Speech Analysis framework types
// These are part of the newer Speech framework APIs

// Translation specific errors
enum TranslationError: Error {
    case sessionInvalidated
    case noResult
}

// Ensure TranscriptionError is defined locally or imported.
enum TranscriptionError: Error {
    case couldNotDownloadModel
    case failedToSetupRecognitionStream
    case invalidAudioDataType
    case localeNotSupported
    case noInternetForModelDownload
    case audioFilePathNotFound
    
    var descriptionString: String {
        switch self {
        case .couldNotDownloadModel: return "Could not download the model."
        case .failedToSetupRecognitionStream: return "Could not set up the speech recognition stream."
        case .invalidAudioDataType: return "Unsupported audio format."
        case .localeNotSupported: return "This locale is not yet supported by SpeechAnalyzer."
        case .noInternetForModelDownload: return "The model could not be downloaded because the user is not connected to internet."
        case .audioFilePathNotFound: return "Couldn't write audio to file."
        }
    }
}

@Observable
final class SpokenWordTranscriber: Sendable {
    
    // MARK: - Properties
    
    private var inputSequence: AsyncStream<AnalyzerInput>?
    private var inputBuilder: AsyncStream<AnalyzerInput>.Continuation?
    private var transcriber: SpeechTranscriber?
    private var analyzer: SpeechAnalyzer?
    private var recognizerTask: Task<(), Error>?
    
    // The format of the audio.
    var analyzerFormat: AVAudioFormat?
    
    var converter = BufferConverter()
    var downloadProgress: Progress?
    
    // Translation using the new Translation Framework
    private var translationSession: TranslationSession?
    private var translationConfiguration: TranslationSession.Configuration?
    
    // Enum to track the status of the translation model download and readiness
    enum TranslationModelStatus: Equatable {
        case notDownloaded
        case downloading(Progress?)
        case ready
        case failed(Error)
        
        // Implement Equatable conformance
        static func == (lhs: TranslationModelStatus, rhs: TranslationModelStatus) -> Bool {
            switch (lhs, rhs) {
            case (.notDownloaded, .notDownloaded):
                return true
            case (.downloading(let lhsProgress), .downloading(let rhsProgress)):
                return lhsProgress?.fractionCompleted == rhsProgress?.fractionCompleted
            case (.ready, .ready):
                return true
            case (.failed(let lhsError), .failed(let rhsError)):
                return lhsError.localizedDescription == rhsError.localizedDescription
            default:
                return false
            }
        }
    }
    // @Observable automatically makes this observable. No @Published needed.
    var translationModelStatus: TranslationModelStatus = .notDownloaded
    
    // Flag to prevent duplicate translation calls
    private var isTranslating = false
    
    // Track the last translated text to avoid re-translating
    private var lastTranslatedText = ""
    
    // Languages for transcription and translation
    // Âä®ÊÄÅËØ≠Ë®ÄËÆæÁΩÆÔºåÈªòËÆ§‰ΩøÁî®Ëã±ËØ≠ÔºàÈÅøÂÖç‰∏çÊîØÊåÅÁöÑËØ≠Ë®Ä‰ª£Á†ÅÔºâ
    var transcriptionLocale = Locale(identifier: "en-US")
    // Use Locale.Language for translation
    var translationSourceLanguage: Locale.Language = .init(identifier: "en-US")
    var translationTargetLanguage: Locale.Language = .init(identifier: "zh-Hans")

    // Transcribed text storage
    var volatileTranscript: AttributedString = ""
    var finalizedTranscript: AttributedString = ""
    
    var story: Binding<VoiceLog>
    
    // MARK: - Initialization
    
    init(story: Binding<VoiceLog>) {
        self.story = story
        // Initially set to not downloaded, will be updated when translation session is available
        self.translationModelStatus = .notDownloaded
        Task {
            await setupTranslation()
        }
    }
    
    // MARK: - Reset Method
    
    func resetTranscription() {
        volatileTranscript = AttributedString("")
        finalizedTranscript = AttributedString("")
        
        // ‰øùÂ≠òÁé∞ÊúâÁöÑaudioTimeRangeÊï∞ÊçÆ
        let existingAudioTimeRangeData = story.wrappedValue.audioTimeRangeData
        
        // Reset the story's text to ensure clean state
        story.wrappedValue.text = AttributedString("")
        
        // ÊÅ¢Â§çaudioTimeRangeÊï∞ÊçÆÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
        if let audioTimeRangeData = existingAudioTimeRangeData {
            story.wrappedValue.audioTimeRangeData = audioTimeRangeData
            print("SpokenWordTranscriber: Preserved existing audioTimeRange data during reset")
        }
        
        // Also reset translated text
        story.wrappedValue.translatedText = nil
        // Reset translation flag and tracking
        isTranslating = false
        lastTranslatedText = ""
        print("SpokenWordTranscriber: Transcription reset to clean state")
        print("Story text after reset: '\(String(story.wrappedValue.text.characters))'")
        print("Story ID: \(story.wrappedValue.id)")
    }
    
    // Method to update story binding
    func updateStoryBinding(_ newStoryBinding: Binding<VoiceLog>) {
        self.story = newStoryBinding
        print("SpokenWordTranscriber: Updated story binding to Story ID: \(newStoryBinding.wrappedValue.id)")
        // Only reset transcription for new/incomplete stories, not for completed ones
        if !newStoryBinding.wrappedValue.isDone {
            resetTranscription()
        } else {
            print("SpokenWordTranscriber: Story is completed, preserving existing transcription")
        }
    }
    
    // MARK: - Translation Setup (using Translation Framework)
    
    private func setupTranslation() async {
        // Create translation configuration
        translationConfiguration = TranslationSession.Configuration(
            source: translationSourceLanguage,
            target: translationTargetLanguage
        )
        
        // Don't set to ready here - wait for the actual translation session to be provided
        print("Translation configuration created, waiting for session...")
    }
    
    // MARK: - Transcription Setup
    
    func setUpTranscriber() async throws {
        print("üó£Ô∏è Setting up transcriber with locale: \(transcriptionLocale)")
        
        transcriber = SpeechTranscriber(locale: transcriptionLocale,
                                        transcriptionOptions: [],
                                        reportingOptions: [.volatileResults],
                                        attributeOptions: [.audioTimeRange])
        
        guard let transcriber else {
            throw TranscriptionError.failedToSetupRecognitionStream
        }
        
        analyzer = SpeechAnalyzer(modules: [transcriber])
        
        do {
            try await ensureModel(transcriber: transcriber, locale: transcriptionLocale)
            print("‚úÖ Speech recognition model loaded successfully for \(transcriptionLocale)")
        } catch let error as TranscriptionError {
            print("‚ùå Failed to load speech recognition model: \(error)")
            return
        }
        
        self.analyzerFormat = await SpeechAnalyzer.bestAvailableAudioFormat(compatibleWith: [transcriber])
        print("üé§ Best available audio format: \(String(describing: analyzerFormat))")
        
        (inputSequence, inputBuilder) = AsyncStream<AnalyzerInput>.makeStream()
        
        guard let inputSequence else { return }
        
        recognizerTask = Task {
            do {
                for try await case let result in transcriber.results {
                    let text = result.text
                    if result.isFinal {
                        finalizedTranscript += text
                        volatileTranscript = ""
                        updateStoryWithNewText(withFinal: text)
                        
                        // Âú®ÂΩïÂà∂ËøáÁ®ã‰∏≠ËøõË°åÂÆûÊó∂ÁøªËØëÔºå‰∏çÈúÄË¶ÅÁ≠âÂæÖURLËÆæÁΩÆ
                        if !story.wrappedValue.isDone {
                            await translateFinalizedTranscript()
                        }
                        
                    } else {
                        volatileTranscript = text
                        volatileTranscript.foregroundColor = .purple.opacity(0.4)
                    }
                }
            } catch {
                print("Speech recognition failed: \(error)")
                try? await finishTranscribing()
            }
        }
        
        try await analyzer?.start(inputSequence: inputSequence)
        print("Speech analyzer started.")
    }
    
    // MARK: - Audio Streaming
    
    func streamAudioToTranscriber(_ buffer: AVAudioPCMBuffer) async throws {
        guard let inputBuilder, let analyzerFormat else {
            throw TranscriptionError.invalidAudioDataType
        }
        
        let convertedBuffer = try self.converter.convertBuffer(buffer, to: analyzerFormat)
        
        let input = AnalyzerInput(buffer: convertedBuffer)
        inputBuilder.yield(input)
    }
    
    // MARK: - Transcription Finalization
    
    public func finishTranscribing() async throws {
        inputBuilder?.finish()
        try await analyzer?.finalizeAndFinishThroughEndOfInput()
        recognizerTask?.cancel()
        recognizerTask = nil
        
        print("finishTranscribing called. Story URL: \(story.wrappedValue.url?.absoluteString ?? "nil"), isDone: \(story.wrappedValue.isDone)")
        print("Final transcript before translation: '\(NSAttributedString(finalizedTranscript).string)'")

        // Âú®ËΩ¨ÂΩïÂÆåÊàêÊó∂ËøõË°åÊúÄÁªàÂÖ®ÈáèÁøªËØëÔºåË¶ÜÁõñ‰πãÂâçÁöÑÂ¢ûÈáèÁøªËØë
        if !story.wrappedValue.isDone {
            print("Triggering final full translation from finishTranscribing")
            await performFinalFullTranslation()
        } else {
            print("Skipping translation: story is already done")
        }
    }
    
    // MARK: - Text Update and Translation
    
    func updateStoryWithNewText(withFinal str: AttributedString) {
        // Âú®Ê∑ªÂä†Êñ∞ÊñáÊú¨‰πãÂâçÔºåÊèêÂèñÂπ∂‰øùÂ≠ò audioTimeRange ‰ø°ÊÅØ
        extractAndSaveAudioTimeRanges(from: str)
        story.wrappedValue.text.append(str)
    }
    
    private func extractAndSaveAudioTimeRanges(from attributedString: AttributedString) {
        // ÊöÇÊó∂ÁÆÄÂåñÂÆûÁé∞Ôºå‰∏ìÊ≥®‰∫éË∞ÉËØï audioTimeRange Â±ûÊÄß
        print("üîç Analyzing AttributedString with \(attributedString.runs.count) runs")
        
        var newTimeRanges: [AudioTimeRangeInfo] = []
        
        attributedString.runs.forEach { run in
            let range = run.range
            let text = String(attributedString[range].characters).prefix(30)
            print("üîç Run text: '\(text)...'")
            
            // Â∞ùËØïÁõ¥Êé•ËÆøÈóÆ audioTimeRange Â±ûÊÄß
            if let audioTimeRange = run.audioTimeRange {
                let startSeconds = audioTimeRange.start.seconds
                let endSeconds = CMTimeAdd(audioTimeRange.start, audioTimeRange.duration).seconds
                print("   üéØ Found audioTimeRange: \(String(format: "%.2f", startSeconds))s - \(String(format: "%.2f", endSeconds))s")
                
                // Â∞Ü AttributedString ÁöÑ range ËΩ¨Êç¢‰∏∫ NSRange
                let nsRange = NSRange(range, in: attributedString)
                let timeRangeInfo = AudioTimeRangeInfo(
                    start: startSeconds,
                    end: endSeconds,
                    range: nsRange
                )
                
                print("   üìù Converting to AudioTimeRangeInfo: start=\(String(format: "%.2f", startSeconds))s, end=\(String(format: "%.2f", endSeconds))s, textRange=\(nsRange)")
                
                newTimeRanges.append(timeRangeInfo)
            } else {
                print("   ‚ö†Ô∏è No audioTimeRange found for this run")
            }
        }
        
        if !newTimeRanges.isEmpty {
            // Ëé∑ÂèñÁé∞ÊúâÁöÑÊó∂Èó¥ËåÉÂõ¥Êï∞ÊçÆÂπ∂ÂêàÂπ∂Êñ∞Êï∞ÊçÆ
            var allTimeRanges = story.wrappedValue.getAudioTimeRanges()
            allTimeRanges.append(contentsOf: newTimeRanges)
            
            // ÊåâÂºÄÂßãÊó∂Èó¥ÊéíÂ∫èÔºåÁ°Æ‰øùÊï∞ÊçÆÁöÑ‰∏ÄËá¥ÊÄß
            allTimeRanges.sort { $0.startSeconds < $1.startSeconds }
            
            // ‰ΩøÁî®Êñ∞ÁöÑÊñπÊ≥ïËÆæÁΩÆÊï∞ÊçÆ
            story.wrappedValue.setAudioTimeRanges(allTimeRanges)
            print("   üíæ Saved audioTimeRange data: \(newTimeRanges.count) new entries, \(allTimeRanges.count) total entries")
            
            // È¢ùÂ§ñÁöÑË∞ÉËØï‰ø°ÊÅØ
            if allTimeRanges.count <= 5 {
                allTimeRanges.forEach { range in
                    print("      Entry: \(String(format: "%.2f", range.startSeconds))s-\(String(format: "%.2f", range.endSeconds))s, range: \(range.textRange)")
                }
            }
            
            // È™åËØÅÊï∞ÊçÆÊòØÂê¶Ê≠£Á°Æ‰øùÂ≠ò
            let verification = story.wrappedValue.getAudioTimeRanges()
            print("   üîç Verification: \(verification.count) entries can be loaded back")
        } else {
            print("   ‚ö†Ô∏è No audioTimeRange data to save")
        }
    }
    
    private func translateFinalizedTranscript() async {
        // Check if we have text to translate and translation is ready
        let textString = NSAttributedString(self.finalizedTranscript).string
        print("translateFinalizedTranscript called with text: '\(textString)'")
        print("Translation session available: \(translationSession != nil)")
        print("Translation model status: \(translationModelStatus)")
        print("Is already translating: \(isTranslating)")
        
        guard !textString.isEmpty else {
            print("No text to translate.")
            return
        }
        
        // Ê£ÄÊü•ÊòØÂê¶ÊúâÊñ∞ÁöÑÊñáÊú¨ÈúÄË¶ÅÁøªËØë
        let newTextToTranslate: String
        if textString.hasPrefix(lastTranslatedText) {
            newTextToTranslate = String(textString.dropFirst(lastTranslatedText.count)).trimmingCharacters(in: .whitespaces)
        } else {
            newTextToTranslate = textString
        }
        
        guard !newTextToTranslate.isEmpty else {
            print("No new text to translate.")
            return
        }
        
        // Prevent duplicate translation calls
        guard !isTranslating else {
            print("Translation already in progress, skipping duplicate call.")
            return
        }
        
        // Check if translation session is still valid (not cleared by view disappearing)
        guard let session = translationSession else {
            print("Translation session not available or has been cleared.")
            return
        }
        
        isTranslating = true
        print("Starting translation of new text: '\(newTextToTranslate)'")
        
        do {
            // Additional check: verify session is still valid before using
            guard let validSession = translationSession else {
                print("Translation session became invalid during execution, aborting translation.")
                Task { @MainActor in
                    self.isTranslating = false
                }
                return
            }
            
            // Perform translation with comprehensive error handling
            let response: Any
            do {
                response = try await validSession.translate(newTextToTranslate)
                
                // Double check session is still valid after translation completes
                guard translationSession != nil else {
                    print("Translation completed but session was invalidated during operation, discarding result.")
                    Task { @MainActor in
                        self.isTranslating = false
                    }
                    return
                }
            } catch {
                // Handle TranslationSession lifecycle errors
                let errorMessage = error.localizedDescription
                if errorMessage.contains("TranslationSession after the view it was attached to has disappeared") ||
                   errorMessage.contains("text session has already been cancelled") ||
                   errorMessage.contains("CancellationError") {
                    print("Translation cancelled due to session invalidation: \(errorMessage)")
                    Task { @MainActor in
                        self.translationSession = nil
                        self.translationModelStatus = .notDownloaded
                        self.isTranslating = false
                    }
                    return
                } else {
                    throw error // Re-throw other errors to be handled by outer catch
                }
            }
            
            Task { @MainActor in
                // Extract the translated text from the response using reflection
                let mirror = Mirror(reflecting: response)
                let translatedText = mirror.children.first { $0.label == "targetText" }?.value as? String ?? ""
                print("Translation result: '\(translatedText)'")
                
                // ÂÆûÊó∂ÁøªËØëÔºöÂ∞ÜÊñ∞ÁøªËØëÁöÑÂÜÖÂÆπËøΩÂä†Âà∞Áé∞ÊúâÁøªËØë‰∏≠
                if let existingTranslation = self.story.wrappedValue.translatedText {
                    let existingText = NSAttributedString(existingTranslation).string
                    let newTranslatedText = existingText + " " + translatedText
                    self.story.wrappedValue.translatedText = AttributedString(newTranslatedText)
                } else {
                    self.story.wrappedValue.translatedText = AttributedString(translatedText)
                }
                
                // Êõ¥Êñ∞Â∑≤ÁøªËØëÁöÑÊñáÊú¨ËÆ∞ÂΩï
                self.lastTranslatedText = textString
                
                self.translationModelStatus = .ready
                self.isTranslating = false
                print("Translation successful. Story.translatedText updated to: '\(self.story.wrappedValue.translatedText != nil ? NSAttributedString(self.story.wrappedValue.translatedText!).string : "")'")
            }
        } catch {
            Task { @MainActor in
                let errorMessage = error.localizedDescription
                print("Translation error: \(errorMessage)")
                
                // Check if this is a TranslationSession lifecycle error
                if errorMessage.contains("TranslationSession after the view it was attached to has disappeared") {
                    print("Refusing new translation request because text session has already been cancelled")
                    // Clear the session reference to prevent further attempts
                    self.translationSession = nil
                    self.translationModelStatus = .notDownloaded
                } else {
                    // Handle other translation errors
                    // Only set to failed if we don't already have a successful translation
                    if self.story.wrappedValue.translatedText == nil || NSAttributedString(self.story.wrappedValue.translatedText!).string.isEmpty {
                        self.translationModelStatus = .failed(error)
                    } else {
                        // Keep status as ready if we already have a translation
                        self.translationModelStatus = .ready
                        print("Translation error occurred but keeping existing translation")
                    }
                }
                self.isTranslating = false
            }
        }
    }
    
    // MARK: - Final Full Translation
    
    private func performFinalFullTranslation() async {
        // Ëé∑ÂèñÂÆåÊï¥ÁöÑËΩ¨ÂΩïÊñáÊú¨
        let fullText = NSAttributedString(self.finalizedTranscript).string.trimmingCharacters(in: .whitespaces)
        
        print("üîÑ Starting final full translation of complete text")
        print("üîÑ Full text length: \(fullText.count) characters")
        print("üîÑ Full text preview: '\(String(fullText.prefix(100)))...'")
        
        guard !fullText.isEmpty else {
            print("üîÑ No text to translate in final translation.")
            return
        }
        
        // Ê£ÄÊü•ÁøªËØë‰ºöËØùÊòØÂê¶ÂèØÁî®ÔºåÂ¶ÇÊûú‰∏çÂèØÁî®ÂàôÁ´ãÂç≥ÈÄÄÂá∫
        // ‰∏çÂÜçÁ≠âÂæÖ‰ºöËØùÈáçÊñ∞ÂàõÂª∫ÔºåËøôÂèØËÉΩÂØºËá¥Âú®ËßÜÂõæÊ∂àÂ§±ÂêéÁöÑËÆøÈóÆ
        if translationSession == nil {
            print("üîÑ Translation session not available, skipping final translation.")
            return
        }
        
        guard let session = translationSession else {
            print("üîÑ Translation session still not available after waiting, skipping final translation.")
            return
        }
        
        // Èò≤Ê≠¢ÈáçÂ§çÁøªËØë
        guard !isTranslating else {
            print("üîÑ Translation already in progress, skipping final translation.")
            return
        }
        
        isTranslating = true
        print("üîÑ Starting final full translation...")
        
        do {
            // Additional check: verify session is still valid before using
            guard let validSession = translationSession else {
                print("üîÑ Translation session became invalid during final translation, aborting.")
                Task { @MainActor in
                    self.isTranslating = false
                }
                return
            }
            
            // ËøõË°åÂÖ®ÈáèÁøªËØëÔºåÂ∏¶‰ºöËØùÈ™åËØÅÂíåÈîôËØØÂ§ÑÁêÜ
            let response: Any
            do {
                response = try await validSession.translate(fullText)
                
                // Double check session is still valid after translation completes
                guard translationSession != nil else {
                    print("üîÑ Final translation completed but session was invalidated during operation, discarding result.")
                    Task { @MainActor in
                        self.isTranslating = false
                    }
                    return
                }
            } catch {
                // Handle TranslationSession lifecycle errors in final translation
                let errorMessage = error.localizedDescription
                if errorMessage.contains("TranslationSession after the view it was attached to has disappeared") ||
                   errorMessage.contains("text session has already been cancelled") ||
                   errorMessage.contains("CancellationError") {
                    print("üîÑ Final translation cancelled due to session invalidation: \(errorMessage)")
                    Task { @MainActor in
                        self.translationSession = nil
                        self.translationModelStatus = .notDownloaded
                        self.isTranslating = false
                    }
                    return
                } else {
                    throw error // Re-throw other errors to be handled by outer catch
                }
            }
            
            Task { @MainActor in
                // Extract the translated text from the response using reflection
                let mirror = Mirror(reflecting: response)
                let fullTranslatedText = mirror.children.first { $0.label == "targetText" }?.value as? String ?? ""
                print("üîÑ Final full translation completed")
                print("üîÑ Translated text length: \(fullTranslatedText.count) characters")
                print("üîÑ Translated text preview: '\(String(fullTranslatedText.prefix(100)))...'")
                
                // Ë¶ÜÁõñ‰πãÂâçÁöÑÂ¢ûÈáèÁøªËØëÁªìÊûú
                self.story.wrappedValue.translatedText = AttributedString(fullTranslatedText)
                
                // Êõ¥Êñ∞ÁøªËØëÁä∂ÊÄÅ
                self.lastTranslatedText = fullText
                self.translationModelStatus = .ready
                self.isTranslating = false
                
                print("üîÑ Final translation successful. Story.translatedText updated with full translation.")
            }
        } catch {
            Task { @MainActor in
                let errorMessage = error.localizedDescription
                print("üîÑ Final translation error: \(errorMessage)")
                
                // Check if this is a TranslationSession lifecycle error
                if errorMessage.contains("TranslationSession after the view it was attached to has disappeared") {
                    print("üîÑ Final translation cancelled due to session invalidation")
                    // Clear the session reference to prevent further attempts
                    self.translationSession = nil
                    self.translationModelStatus = .notDownloaded
                } else {
                    // Â¶ÇÊûúÊúÄÁªàÁøªËØëÂ§±Ë¥•Ôºå‰øùÁïô‰πãÂâçÁöÑÂ¢ûÈáèÁøªËØëÁªìÊûú
                    self.translationModelStatus = .ready
                    print("üîÑ Final translation failed, keeping existing incremental translation")
                }
                self.isTranslating = false
            }
        }
    }
    
    private func setupTranslationSession() async {
        guard let configuration = translationConfiguration else { return }
        
        // TranslationSession will be provided by the view using .translationTask
        // For now, we'll mark as ready and let the UI handle the session creation
        self.translationModelStatus = .ready
    }
    
    // MARK: - Public Properties for UI
    
    var transcriptionLocaleIdentifier: String {
        transcriptionLocale.identifier
    }
    
    var translationStatusDescription: String {
        switch translationModelStatus {
        case .ready: return "Translation model: Ready."
        case .downloading(let progress): return "Translation model: Downloading (\(Int((progress?.fractionCompleted ?? 0) * 100))%)..."
        case .failed(let error): return "Translation model: Failed (\(error.localizedDescription))"
        case .notDownloaded: return "Translation model: Not downloaded."
        }
    }
    
    // Method to set translation session from view
    func setTranslationSession(_ session: TranslationSession) {
        self.translationSession = session
        self.translationModelStatus = .ready
        print("üîß SpokenWordTranscriber: Translation session set, model is ready.")
        print("üîß SpokenWordTranscriber: Session object: \(session)")
    }
    
    // Method to clear translation session when view disappears
    func clearTranslationSession() {
        print("üßπ Clearing translation session reference")
        
        // Immediately clear the session reference to prevent any further use
        // This must be done FIRST to prevent race conditions
        self.translationSession = nil
        self.translationModelStatus = .notDownloaded
        
        // Cancel any ongoing translation attempts
        if isTranslating {
            print("üßπ Cancelling ongoing translation")
            isTranslating = false
        }
        
        // Reset translation tracking
        lastTranslatedText = ""
        
        print("üßπ Translation session cleared successfully")
    }
    
    // Method to update language settings
    func updateLanguageSettings(sourceLanguage: String, targetLanguage: String) async {
        print("üåê Updating language settings: \(sourceLanguage) ‚Üí \(targetLanguage)")
        
        let newLocale = Locale(identifier: sourceLanguage)
        
        // Ê£ÄÊü•ËØ≠Èü≥ËØÜÂà´ÊòØÂê¶ÊîØÊåÅËøô‰∏™ËØ≠Ë®Ä
        let isSupported = await supported(locale: newLocale)
        if !isSupported {
            print("‚ö†Ô∏è Language \(sourceLanguage) is not supported for speech recognition")
            print("‚ö†Ô∏è Falling back to en-US")
            transcriptionLocale = Locale(identifier: "en-US")
        } else {
            transcriptionLocale = newLocale
            print("‚úÖ Language \(sourceLanguage) is supported for speech recognition")
        }
        
        // Update translation languages
        translationSourceLanguage = Locale.Language(identifier: sourceLanguage)
        translationTargetLanguage = Locale.Language(identifier: targetLanguage)
        
        // Update translation configuration
        translationConfiguration = TranslationSession.Configuration(
            source: translationSourceLanguage,
            target: translationTargetLanguage
        )
        
        print("üåê Language settings updated successfully")
        print("üåê Transcription locale: \(transcriptionLocale)")
        print("üåê Translation: \(translationSourceLanguage) ‚Üí \(translationTargetLanguage)")
    }
    
    // Method to get supported locales for UI
    func getSupportedLocales() async -> Set<String> {
        let supportedLocales = await SpeechTranscriber.supportedLocales
        return Set(supportedLocales.map { $0.identifier })
    }
    
    // Method to manually trigger translation model preparation
    func prepareTranslationModel() async {
        self.translationModelStatus = .downloading(nil)
        
        // Simulate some preparation time (in real app, this might involve actual model download)
        try? await Task.sleep(nanoseconds: 1_000_000_000) // 1 second
        
        if translationSession != nil {
            self.translationModelStatus = .ready
        } else {
            self.translationModelStatus = .notDownloaded
        }
    }
    
    // Method to retry translation
    func retryTranslation() async {
        print("Retrying translation...")
        
        // Check if translation session is still available
        guard translationSession != nil else {
            print("Cannot retry translation: Translation session not available")
            translationModelStatus = .notDownloaded
            return
        }
        
        isTranslating = false // Reset the flag
        translationModelStatus = .ready // Reset the status
        await translateFinalizedTranscript()
    }
    
    deinit {
        // Clean up tasks
        recognizerTask?.cancel()
    }
}

// MARK: - Model Management Extensions

extension SpokenWordTranscriber {
    public func ensureModel(transcriber: SpeechTranscriber, locale: Locale) async throws {
        guard await supported(locale: locale) else {
            throw TranscriptionError.localeNotSupported
        }
        
        if await installed(locale: locale) {
            return
        } else {
            try await downloadIfNeeded(for: transcriber)
        }
    }
    
    func supported(locale: Locale) async -> Bool {
        let supported = await SpeechTranscriber.supportedLocales
        return supported.map { $0.identifier }.contains(locale.identifier)
    }

    func installed(locale: Locale) async -> Bool {
        let installed = await Set(SpeechTranscriber.installedLocales)
        return installed.map { $0.identifier }.contains(locale.identifier)
    }

    func downloadIfNeeded(for module: SpeechTranscriber) async throws {
        if let downloader = try await AssetInventory.assetInstallationRequest(supporting: [module]) {
            self.downloadProgress = downloader.progress
            try await downloader.downloadAndInstall()
        }
    }
    
    func deallocate() async {
        let allocated = await AssetInventory.allocatedLocales
        for locale in allocated {
            await AssetInventory.deallocate(locale: locale)
        }
    }
}
